<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>iPad Express Checkout - Phase II</title>

  <!-- ZXing QR Code Library - Better iOS Compatibility -->
  <script src="https://unpkg.com/@zxing/library@0.20.0/umd/index.min.js"></script>

  <style>
    :root{
      --primary:#4f46e5;
      --success:#10b981;
      --bg:#0f172a;
      --panel:#1e293b;
      --danger:#ef4444;
      --gray:#334155;
      --warning:#f59e0b;
      --vh:1vh;
      
      /* PHASE II: Semantic Color Coding */
      --actionable-blue:#3b82f6;
      --active-zone:#1e3a8a;
      --audit-grey:#64748b;
      --historical-bg:#334155;
    }

    *{ box-sizing:border-box; }

    body{
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);
      color:#fff;
      margin:0;
      display:flex;
      flex-direction:column;
      height:calc(var(--vh) * 100);
      overflow:hidden;
      -webkit-user-select:none;
      -webkit-tap-highlight-color:transparent;
      padding-top:env(safe-area-inset-top);
      padding-bottom:env(safe-area-inset-bottom);
    }

    .header{
      padding:10px;
      background:var(--panel);
      border-bottom:1px solid var(--gray);
      flex-shrink:0;
    }

    .mode-toggle{
      display:flex;
      background:#0f172a;
      border-radius:10px;
      padding:4px;
      margin:0 auto;
      width:min(520px, 100%);
    }

    .mode-btn{
      flex:1;
      padding:12px;
      border:none;
      border-radius:8px;
      color:#94a3b8;
      background:none;
      font-size:1.05rem;
      font-weight:800;
      cursor:pointer;
      transition:0.2s;
    }

    .mode-btn.active{
      background:var(--primary);
      color:#fff;
    }

    #reader-container{
      width:min(560px, 100%);
      margin:10px auto 0;
      padding:0 12px;
      position:relative;
      flex-shrink:0;
    }

    #reader{
      width:100% !important;
      height:clamp(220px, 38vh, 360px) !important;
      background:#000;
      border-radius:14px;
      overflow:hidden;
      border:2px solid var(--gray);
      object-fit:cover;
      display:block;
      transform: translateZ(0);
      -webkit-transform: translateZ(0);
    }

    @supports (-webkit-touch-callout: none) {
      #reader {
        height: calc(clamp(220px, 38vh, 360px) - env(safe-area-inset-bottom)) !important;
      }
    }

    .scan-overlay{
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(-50%, -50%);
      width:min(260px, 72vw);
      height:min(260px, 72vw);
      max-width:260px;
      max-height:260px;
      border:3px solid var(--success);
      border-radius:14px;
      pointer-events:none;
      opacity:0.55;
      transition:all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .scan-overlay.scanning{
      animation:pulse 2s infinite;
    }

    .scan-overlay.cooldown{
      border-color:var(--warning);
      opacity:0.3;
      animation:none;
    }

    .scan-overlay.feedback-success {
      border-color: #10b981;
      box-shadow: 0 0 40px rgba(16, 185, 129, 0.6);
      animation: successPulse 0.5s ease-out;
    }

    .scan-overlay.feedback-error {
      border-color: #ef4444;
      box-shadow: 0 0 40px rgba(239, 68, 68, 0.6);
      animation: errorShake 0.5s ease-out;
    }

    /* PHASE II: Visual Vibration Fallback */
    .scan-overlay.visual-shake {
      animation: visualShake 0.5s cubic-bezier(.36,.07,.19,.97) both;
    }

    @keyframes visualShake {
      10%, 90% { transform: translate(-50%, -50%) translateX(-5px); }
      20%, 80% { transform: translate(-50%, -50%) translateX(5px); }
      30%, 50%, 70% { transform: translate(-50%, -50%) translateX(-3px); }
      40%, 60% { transform: translate(-50%, -50%) translateX(3px); }
    }

    @keyframes pulse{
      0%,100%{ opacity:0.55; }
      50%{ opacity:0.25; }
    }

    @keyframes successPulse {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.05); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }

    @keyframes errorShake {
      0%, 100% { transform: translate(-50%, -50%) translateX(0); }
      25% { transform: translate(-50%, -50%) translateX(-10px); }
      75% { transform: translate(-50%, -50%) translateX(10px); }
    }

    .scan-corner{
      position:absolute;
      width:30px;
      height:30px;
      border:3px solid var(--success);
      transition:border-color 0.2s;
    }
    
    .scan-overlay.cooldown .scan-corner,
    .scan-overlay.feedback-error .scan-corner{
      border-color:var(--warning);
    }

    .scan-overlay.feedback-success .scan-corner{
      border-color:#10b981;
    }
    
    .scan-corner.tl{ top:0; left:0; border-right:none; border-bottom:none; }
    .scan-corner.tr{ top:0; right:0; border-left:none; border-bottom:none; }
    .scan-corner.bl{ bottom:0; left:0; border-right:none; border-top:none; }
    .scan-corner.br{ bottom:0; right:0; border-left:none; border-top:none; }

    /* ===== USER CONFIRMATION MODAL ===== */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(15, 23, 42, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      animation: fadeIn 0.2s ease-out;
    }

    .modal-content {
      background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
      border: 3px solid #10b981;
      border-radius: 24px;
      padding: 40px;
      text-align: center;
      max-width: 90%;
      width: 420px;
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
    }

    .checkmark-icon {
      width: 80px;
      height: 80px;
      background: #10b981;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      color: white;
      margin: 0 auto 20px;
      animation: scaleIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    .modal-content h2 {
      margin: 0 0 16px;
      font-size: 28px;
      color: #fff;
    }

    .user-info {
      font-size: 18px;
      color: #cbd5e1;
      margin-bottom: 24px;
    }

    .user-info strong {
      display: block;
      font-size: 24px;
      color: #10b981;
      margin-bottom: 8px;
      font-family: monospace;
    }

    .next-step {
      background: rgba(79, 70, 229, 0.2);
      border: 2px dashed #4f46e5;
      border-radius: 16px;
      padding: 20px;
      margin: 24px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
    }

    .arrow-icon {
      font-size: 32px;
      color: #4f46e5;
      animation: bounce 1s infinite;
    }

    .next-step p {
      margin: 0;
      font-size: 18px;
      color: #e2e8f0;
      font-weight: 600;
    }

    .modal-close {
      background: #10b981;
      color: white;
      border: none;
      padding: 14px 32px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      margin-top: 16px;
      transition: background 0.2s;
    }

    .modal-close:hover {
      background: #059669;
    }

    /* PHASE II: Transaction Confirmation Modal */
    .confirmation-modal .modal-content {
      border-color: var(--actionable-blue);
      max-width: 95%;
      width: 500px;
    }

    .confirmation-modal .warning-icon {
      width: 80px;
      height: 80px;
      background: var(--actionable-blue);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      color: white;
      margin: 0 auto 20px;
      animation: scaleIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    .transaction-summary {
      background: rgba(59, 130, 246, 0.1);
      border: 2px solid var(--actionable-blue);
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
      text-align: left;
    }

    .transaction-summary h3 {
      margin: 0 0 16px;
      font-size: 18px;
      color: var(--actionable-blue);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .transaction-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .transaction-item:last-child {
      border-bottom: none;
    }

    .transaction-label {
      font-size: 14px;
      color: #94a3b8;
      font-weight: 600;
    }

    .transaction-value {
      font-size: 16px;
      color: #e2e8f0;
      font-family: monospace;
      font-weight: 700;
    }

    .asset-count {
      background: var(--actionable-blue);
      color: white;
      padding: 6px 16px;
      border-radius: 20px;
      font-size: 18px;
      font-weight: 900;
    }

    .modal-actions {
      display: flex;
      gap: 12px;
      margin-top: 24px;
    }

    .modal-btn {
      flex: 1;
      padding: 16px;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }

    .modal-btn-cancel {
      background: var(--gray);
      color: white;
    }

    .modal-btn-cancel:hover {
      background: #475569;
    }

    .modal-btn-confirm {
      background: var(--actionable-blue);
      color: white;
    }

    .modal-btn-confirm:hover {
      background: #2563eb;
    }

    /* PHASE II: Error Modal */
    .error-modal .modal-content {
      border-color: var(--danger);
    }

    .error-modal .error-icon {
      width: 80px;
      height: 80px;
      background: var(--danger);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      color: white;
      margin: 0 auto 20px;
      animation: scaleIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    .error-details {
      background: rgba(239, 68, 68, 0.1);
      border: 2px solid var(--danger);
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
      text-align: left;
    }

    .error-details code {
      display: block;
      background: rgba(0, 0, 0, 0.3);
      padding: 12px;
      border-radius: 8px;
      font-family: monospace;
      font-size: 14px;
      color: #fca5a5;
      margin-top: 12px;
      word-break: break-all;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes scaleIn {
      from { transform: scale(0); }
      to { transform: scale(1); }
    }

    @keyframes bounce {
      0%, 100% { transform: translateX(0); }
      50% { transform: translateX(8px); }
    }

    .fade-out {
      animation: fadeOut 0.3s ease-in forwards;
    }

    @keyframes fadeOut {
      to { opacity: 0; transform: scale(0.95); }
    }

    /* ===== SCREEN FLASH FEEDBACK ===== */
    .screen-flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 99999;
      animation: flashEffect 0.4s ease-out;
      mix-blend-mode: screen;
    }

    .screen-flash-success {
      background: radial-gradient(circle, rgba(16, 185, 129, 0.4) 0%, transparent 70%);
    }

    .screen-flash-error {
      background: radial-gradient(circle, rgba(239, 68, 68, 0.5) 0%, transparent 70%);
    }

    .screen-flash-warning {
      background: radial-gradient(circle, rgba(245, 158, 11, 0.4) 0%, transparent 70%);
    }

    .screen-flash-complete {
      background: radial-gradient(circle, rgba(79, 70, 229, 0.5) 0%, transparent 70%);
    }

    @keyframes flashEffect {
      0% { opacity: 0; transform: scale(0.8); }
      50% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(1.1); }
    }

    @media (prefers-reduced-motion: reduce) {
      .screen-flash, .checkmark-icon, .arrow-icon, .scan-overlay {
        animation: none !important;
      }
    }

    .start-overlay{
      position:absolute;
      inset:0 12px 0 12px;
      display:flex;
      align-items:center;
      justify-content:center;
      background:rgba(15,23,42,0.65);
      backdrop-filter:blur(8px);
      z-index:100;
    }

    .start-btn{
      background:linear-gradient(135deg, var(--primary) 0%, #6366f1 100%);
      color:#fff;
      font-size:1.2rem;
      padding:20px 48px;
      border:none;
      border-radius:50px;
      cursor:pointer;
      font-weight:800;
      box-shadow:0 10px 30px rgba(79,70,229,0.4);
      transition:0.3s;
    }

    .start-btn:active{ transform:scale(0.95); }

    .status-banner{
      padding:14px;
      text-align:center;
      font-weight:900;
      font-size:0.95rem;
      letter-spacing:0.5px;
      transition:0.2s;
    }

    .status-waiting{ background:#334155; color:#e2e8f0; }
    .status-success{ background:var(--success); color:#fff; }
    .status-error{ background:var(--danger); color:#fff; }
    .status-warning{ background:var(--warning); color:#000; }

    /* PHASE II: Active Zone with Card Elevation (Z-Axis Depth) */
    .user-panel{
      display:none;
      align-items:center;
      justify-content:space-between;
      background: linear-gradient(135deg, var(--active-zone) 0%, #1e40af 100%);
      padding:16px 18px;
      margin:12px 12px 0;
      border-radius:16px;
      border:2px solid var(--actionable-blue);
      box-shadow: 0 8px 24px rgba(59, 130, 246, 0.3),
                  0 4px 8px rgba(0, 0, 0, 0.4);
      position: relative;
      z-index: 10;
    }

    .user-panel::before {
      content: "";
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(135deg, var(--actionable-blue), #60a5fa);
      border-radius: 16px;
      z-index: -1;
      opacity: 0.5;
      filter: blur(8px);
    }

    .user-label{ 
      font-size:0.75rem; 
      color:#93c5fd; 
      margin-bottom:6px;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 700;
    }

    #currentUserId{
      font-size:1.3rem;
      font-weight:900;
      color:#fff;
      font-family:monospace;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .clear-btn{
      background:var(--danger);
      color:#fff;
      border:none;
      padding:12px 20px;
      border-radius:10px;
      font-size:0.85rem;
      font-weight:700;
      cursor:pointer;
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
      transition: all 0.2s;
    }

    .clear-btn:active {
      transform: scale(0.95);
    }

    /* PHASE II: Historical/Audit Zone with Flat Design */
    .history-section{
      flex:1;
      overflow-y:auto;
      padding:8px 12px 12px;
      background: transparent;
    }

    .history-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:12px 4px;
      border-bottom: 2px solid var(--audit-grey);
      margin-bottom: 12px;
    }

    .history-title{
      font-size:0.85rem;
      font-weight:900;
      color:var(--audit-grey);
      text-transform:uppercase;
      letter-spacing:1px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .history-icon {
      width: 20px;
      height: 20px;
      opacity: 0.6;
    }

    #sessionCount{
      background:var(--audit-grey);
      color:#fff;
      padding:6px 14px;
      border-radius:8px;
      font-size:0.85rem;
      font-weight:900;
    }

    #historyList{
      display:none;
    }

    .history-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      background:var(--historical-bg);
      padding:12px 14px;
      margin:6px 0;
      border-radius:10px;
      border:1px solid rgba(100, 116, 139, 0.3);
      box-shadow: none;
      transition: background 0.2s;
    }

    .history-row:hover {
      background: #3f4b5b;
    }

    /* PHASE III: Status-aware history rows */
    .history-row.status-pending {
      border-left: 4px solid #94a3b8;
    }

    .history-row.status-success {
      border-left: 4px solid #10b981;
      background: rgba(16, 185, 129, 0.08);
    }

    .history-row.status-failed {
      border-left: 4px solid #ef4444;
      background: rgba(239, 68, 68, 0.12);
      animation: failedPulse 0.5s ease-out;
    }

    @keyframes failedPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.02); }
      100% { transform: scale(1); }
    }

    .history-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .history-label{
      font-family:monospace;
      font-weight:600;
      color:#cbd5e1;
      font-size:1rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-icon {
      font-size: 1.1rem;
      line-height: 1;
    }

    .status-icon.pending {
      color: #94a3b8;
    }

    .status-icon.success {
      color: #10b981;
    }

    .status-icon.failed {
      color: #ef4444;
    }

    .error-reason {
      font-size: 0.75rem;
      color: #fca5a5;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      font-weight: 600;
      margin-top: 2px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .error-reason::before {
      content: "‚ö†Ô∏è";
      font-size: 0.85rem;
    }

    .delete-btn{
      background:var(--danger);
      color:#fff;
      border:none;
      padding:8px 14px;
      border-radius:6px;
      font-size:0.75rem;
      font-weight:700;
      cursor:pointer;
      transition: all 0.2s;
    }

    .delete-btn:active {
      transform: scale(0.95);
    }

    .footer{
      flex-shrink:0;
      padding:12px;
      background:var(--panel);
      border-top:1px solid var(--gray);
    }

    .finish-btn{
      width:100%;
      background:linear-gradient(135deg, var(--success) 0%, #059669 100%);
      color:#fff;
      padding:18px;
      border:none;
      border-radius:12px;
      font-size:1.1rem;
      font-weight:900;
      cursor:pointer;
      box-shadow:0 8px 25px rgba(16,185,129,0.3);
      transition:0.3s;
    }

    .finish-btn:disabled{
      background:#475569;
      cursor:not-allowed;
      box-shadow:none;
    }

    .finish-btn:active:not(:disabled){ transform:scale(0.97); }
  </style>
</head>
<body>
  <div class="header">
    <div class="mode-toggle">
      <button id="btnBorrow" class="mode-btn active" onclick="setMode('borrow')">BORROW</button>
      <button id="btnReturn" class="mode-btn" onclick="setMode('return')">RETURN</button>
    </div>
  </div>

  <div id="reader-container">
    <video id="reader" autoplay playsinline></video>
    <div class="scan-overlay scanning">
      <div class="scan-corner tl"></div>
      <div class="scan-corner tr"></div>
      <div class="scan-corner bl"></div>
      <div class="scan-corner br"></div>
    </div>
    <div id="startOverlay" class="start-overlay">
      <button class="start-btn" onclick="userStart()">SCAN QR CODE</button>
    </div>
  </div>

  <div class="status-banner status-waiting" id="statusBanner">TAP "SCAN QR CODE" TO BEGIN</div>

  <div class="user-panel" id="userPanel">
    <div>
      <div class="user-label">üéØ Active User</div>
      <div id="currentUserId">‚Äî</div>
    </div>
    <button class="clear-btn" onclick="clearAll()">CLEAR</button>
  </div>

  <div class="history-section">
    <div class="history-header">
      <div class="history-title">
        <span class="history-icon">üìã</span>
        Session Items
      </div>
      <div id="sessionCount">Qty: 0</div>
    </div>
    <div id="historyList"></div>
  </div>

  <div class="footer">
    <button id="finishBtn" class="finish-btn" onclick="showConfirmationModal()">FINISH & SAVE</button>
  </div>

  <script>
    // ===== CONFIG =====
    const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbza6JTVJybMndWQ6dvzR-g8N70nGsyaL1GaROCEzc2ia1_gcjiRD7CrJ2YE5nkI5C8R/exec"; // UPDATE THIS
    const DEBUG_MODE = true;
    const DUPLICATE_WINDOW = 2000;
    const COOLDOWN_DURATION = 1500;

    // ===== STATE =====
    let mode = "borrow";
    let userId = null;
    let sessionHistory = [];
    let historyDom = new Map();
    let ipadStatus = new Map(); // PHASE III: Track success/failure status per iPad
    let unavailableIpads = [];
    let knownUsersSet = new Set();
    let knownIpadsSet = new Set();
    let lastScanned = null;
    let lastScanTime = 0;
    let isProcessing = false;
    let isInCooldown = false;
    let cooldownTimer = null;
    let codeReader = null;

    // PHASE II: Haptic Capability Detection
    let hapticCapable = false;
    let deviceInfo = {
      isIOS: /iPhone|iPad|iPod/.test(navigator.userAgent),
      isSafari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
      userAgent: navigator.userAgent
    };

    // ===== AUDIO SYSTEM =====
    
    let audioCtx = null;
    let audioReady = false;
    let audioBuffers = {
      success: null,
      error: null,
      complete: null
    };

    async function initEnhancedAudio() {
      if (audioReady) return;
      
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        audioBuffers.success = generateSuccessChime(audioCtx);
        audioBuffers.error = generateErrorBuzz(audioCtx);
        audioBuffers.complete = generateCompleteTriad(audioCtx);
        
        if (audioCtx.state === 'suspended') {
          await audioCtx.resume();
        }
        
        audioReady = true;
        log('‚úì Enhanced audio system initialized');
      } catch (err) {
        console.error('Audio initialization failed:', err);
      }
    }

    function generateSuccessChime(ctx) {
      const sampleRate = ctx.sampleRate;
      const duration = 0.15;
      const buffer = ctx.createBuffer(1, sampleRate * duration, sampleRate);
      const data = buffer.getChannelData(0);
      
      const freq = 880;
      for (let i = 0; i < buffer.length; i++) {
        const t = i / sampleRate;
        const envelope = Math.exp(-t * 15);
        const wave = Math.sin(2 * Math.PI * freq * t);
        data[i] = wave * envelope * 0.15;
      }
      return buffer;
    }

    function generateErrorBuzz(ctx) {
      const sampleRate = ctx.sampleRate;
      const duration = 0.2;
      const buffer = ctx.createBuffer(1, sampleRate * duration, sampleRate);
      const data = buffer.getChannelData(0);
      
      for (let i = 0; i < buffer.length; i++) {
        const t = i / sampleRate;
        const progress = t / duration;
        const freq = 350 - (progress * 120);
        const envelope = Math.exp(-t * 8);
        const wave = Math.sin(2 * Math.PI * freq * t);
        data[i] = wave * envelope * 0.12;
      }
      return buffer;
    }

    function generateCompleteTriad(ctx) {
      const sampleRate = ctx.sampleRate;
      const duration = 0.25;
      const buffer = ctx.createBuffer(1, sampleRate * duration, sampleRate);
      const data = buffer.getChannelData(0);
      
      const freqs = [523.25, 659.25, 783.99];
      
      for (let i = 0; i < buffer.length; i++) {
        const t = i / sampleRate;
        const envelope = Math.exp(-t * 6);
        let sample = 0;
        
        for (const freq of freqs) {
          sample += Math.sin(2 * Math.PI * freq * t) * 0.05;
        }
        
        data[i] = sample * envelope;
      }
      return buffer;
    }

    function playAudioBuffer(buffer) {
      if (!audioReady || !buffer || !audioCtx) return;
      
      try {
        if (audioCtx.state === "suspended") {
          audioCtx.resume().then(() => {
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(audioCtx.destination);
            source.start(0);
          }).catch(err => {
            console.error("AudioContext resume failed:", err);
          });
        } else {
          const source = audioCtx.createBufferSource();
          source.buffer = buffer;
          source.connect(audioCtx.destination);
          source.start(0);
        }
      } catch (e) {
        console.error("Audio playback failed:", e);
      }
    }

    // ===== PHASE II: ENHANCED HAPTIC WITH GRACEFUL DEGRADATION =====
    
    /**
     * Initialize and test haptic capabilities
     */
    function initHapticCapabilities() {
      if (!navigator.vibrate) {
        log('‚ö†Ô∏è Vibration API not supported');
        hapticCapable = false;
        return;
      }

      // PHASE II: User-Agent compatibility check
      // Safari iOS has historically restricted Vibration API
      if (deviceInfo.isIOS && !deviceInfo.isSafari) {
        log('‚ö†Ô∏è iOS detected but not Safari - vibration may be restricted');
      }

      // Test vibration
      try {
        const testResult = navigator.vibrate(1);
        hapticCapable = testResult;
        log(`‚úì Haptic capability: ${hapticCapable ? 'ENABLED' : 'DISABLED'}`);
      } catch (err) {
        log('‚ö†Ô∏è Vibration test failed:', err);
        hapticCapable = false;
      }

      log('Device Info:', deviceInfo);
    }

    /**
     * Trigger haptic with automatic fallback to visual vibration
     */
    function triggerHaptic(type) {
      const patterns = {
        success: [25],
        error: [50, 100, 50],
        warning: [30, 50, 30],
        complete: [50, 100, 50, 100, 100]
      };
      
      if (hapticCapable) {
        try {
          const result = navigator.vibrate(patterns[type] || [25]);
          if (result) {
            log(`‚úì Haptic: ${type}`);
            return;
          }
        } catch (err) {
          log('‚ö†Ô∏è Haptic failed, falling back to visual');
        }
      }

      // PHASE II: Graceful Degradation - Visual Vibration
      triggerVisualVibration(type);
    }

    /**
     * PHASE II: Visual Vibration Fallback
     * Provides shake animation when hardware haptics unavailable
     */
    function triggerVisualVibration(type) {
      const overlay = document.querySelector('.scan-overlay');
      
      if (type === 'error' || type === 'warning') {
        overlay.classList.add('visual-shake');
        setTimeout(() => {
          overlay.classList.remove('visual-shake');
        }, 500);
        log(`‚úì Visual vibration (fallback): ${type}`);
      }
    }

    function triggerScreenFlash(type) {
      const overlay = document.createElement('div');
      overlay.className = `screen-flash screen-flash-${type}`;
      document.body.appendChild(overlay);
      setTimeout(() => overlay.remove(), 400);
    }

    function triggerOverlayFeedback(type) {
      const overlay = document.querySelector('.scan-overlay');
      overlay.classList.add(`feedback-${type}`);
      setTimeout(() => {
        overlay.classList.remove(`feedback-${type}`);
      }, 500);
    }

    function triggerFeedback(type) {
      triggerHaptic(type);
      triggerScreenFlash(type);
      triggerOverlayFeedback(type);
      
      const audioMap = {
        success: audioBuffers.success,
        error: audioBuffers.error,
        warning: audioBuffers.error,
        complete: audioBuffers.complete
      };
      
      if (audioMap[type]) {
        playAudioBuffer(audioMap[type]);
      }
      
      console.log(`üéØ Multi-sensory feedback: ${type}`);
    }

    // ===== PHASE II: TRANSACTION CONFIRMATION MODAL =====
    
    /**
     * Show pre-submission confirmation gateway
     */
    function showConfirmationModal() {
      if (!userId || sessionHistory.length === 0 || isProcessing) return;

      const modal = document.createElement('div');
      modal.id = 'confirmationModal';
      modal.className = 'modal-overlay confirmation-modal';
      
      const actionLabel = mode === 'borrow' ? 'Checkout' : 'Return';
      
      modal.innerHTML = `
        <div class="modal-content">
          <div class="warning-icon">‚ö†Ô∏è</div>
          <h2>Confirm ${actionLabel}</h2>
          
          <div class="transaction-summary">
            <h3>${actionLabel} Summary</h3>
            
            <div class="transaction-item">
              <span class="transaction-label">User ID:</span>
              <span class="transaction-value">${userId}</span>
            </div>
            
            <div class="transaction-item">
              <span class="transaction-label">Action:</span>
              <span class="transaction-value">${mode.toUpperCase()}</span>
            </div>
            
            <div class="transaction-item">
              <span class="transaction-label">Asset Count:</span>
              <span class="asset-count">${sessionHistory.length}</span>
            </div>
          </div>
          
          <p style="color: #94a3b8; font-size: 14px; margin: 16px 0;">
            ${mode === 'borrow' 
              ? 'You are about to check out these iPads. Ensure all IDs are correct.'
              : 'You are about to return these iPads. This will remove them from the borrowed list.'}
          </p>
          
          <div class="modal-actions">
            <button class="modal-btn modal-btn-cancel" onclick="dismissConfirmationModal()">
              Cancel
            </button>
            <button class="modal-btn modal-btn-confirm" onclick="confirmAndProceed()">
              Confirm & Proceed
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      triggerFeedback('warning');
    }

    function dismissConfirmationModal() {
      const modal = document.getElementById('confirmationModal');
      if (modal) {
        modal.classList.add('fade-out');
        setTimeout(() => modal.remove(), 300);
      }
    }

    async function confirmAndProceed() {
      dismissConfirmationModal();
      await finishSession();
    }

    // ===== PHASE II: ERROR MODAL WITH SPECIFIC CODES =====
    
    /**
     * Show detailed error modal with backend error codes
     */
    function showErrorModal(errorCode, errorMessage, details = {}) {
      const modal = document.createElement('div');
      modal.id = 'errorModal';
      modal.className = 'modal-overlay error-modal';
      
      modal.innerHTML = `
        <div class="modal-content">
          <div class="error-icon">‚ùå</div>
          <h2>Transaction Failed</h2>
          
          <div class="error-details">
            <p style="margin: 0 0 12px; color: #fca5a5; font-weight: 700;">
              Error Code: ${errorCode}
            </p>
            <p style="margin: 0; color: #e2e8f0; font-size: 15px;">
              ${errorMessage}
            </p>
            ${details.ipadId ? `<code>Asset ID: ${details.ipadId}</code>` : ''}
            ${details.reason ? `<code>Reason: ${details.reason}</code>` : ''}
          </div>
          
          <p style="color: #94a3b8; font-size: 13px; margin: 16px 0;">
            ${getErrorGuidance(errorCode)}
          </p>
          
          <button class="modal-close" onclick="dismissErrorModal()">
            Close
          </button>
        </div>
      `;
      
      document.body.appendChild(modal);
      triggerFeedback('error');
    }

    function getErrorGuidance(errorCode) {
      const guidance = {
        'NOT_BORROWED': 'üí° This iPad is not currently checked out. Please verify you scanned the correct asset tag.',
        'ASSET_NOT_FOUND': '‚ö†Ô∏è This iPad is not in our system. Please contact the tech office for assistance.',
        'ASSET_BLOCKED': 'üîí This iPad is currently reserved or under maintenance and cannot be borrowed at this time.',
        'USER_NOT_FOUND': 'üë§ User ID not recognized. Please scan your student/staff ID card again.',
        'ALREADY_BORROWED': 'üì± This iPad is already checked out to another user. Please select a different iPad.',
        'VALIDATION_ERROR': '‚ö†Ô∏è This iPad was borrowed by someone else. Only the person who checked it out can return it.',
        'NETWORK_ERROR': 'üì° Cannot connect to server. Please check your internet connection and try again.',
        'UNKNOWN': '‚ùì Something went wrong. Please contact tech support if this problem continues.'
      };
      
      return guidance[errorCode] || guidance['UNKNOWN'];
    }

    function dismissErrorModal() {
      const modal = document.getElementById('errorModal');
      if (modal) {
        modal.classList.add('fade-out');
        setTimeout(() => modal.remove(), 300);
      }
    }

    // ===== USER CONFIRMATION MODAL (from Phase I) =====
    
    function showUserConfirmationModal(userId, userName) {
      const existingModal = document.getElementById('userConfirmModal');
      if (existingModal) existingModal.remove();
      
      const modal = document.createElement('div');
      modal.id = 'userConfirmModal';
      modal.innerHTML = `
        <div class="modal-overlay">
          <div class="modal-content">
            <div class="checkmark-icon">‚úì</div>
            <h2>User Verified</h2>
            <div class="user-info">
              <strong>${userId}</strong>
              ${userName ? userName : ''}
            </div>
            <div class="next-step">
              <div class="arrow-icon">‚Üí</div>
              <p>Now scan iPad asset tags</p>
            </div>
            <button class="modal-close" onclick="dismissModal()">Continue</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      setTimeout(() => dismissModal(), 2500);
    }

    function dismissModal() {
      const modal = document.getElementById('userConfirmModal');
      if (modal) {
        modal.classList.add('fade-out');
        setTimeout(() => modal.remove(), 300);
      }
    }

    // ===== ZXING QR SCANNER =====
    
    function log(...args) {
      if (DEBUG_MODE) console.log(...args);
    }

    function setVhUnit() {
      const vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty("--vh", `${vh}px`);
    }
    
    window.addEventListener("resize", setVhUnit);
    window.addEventListener("orientationchange", () => setTimeout(setVhUnit, 250));
    setVhUnit();

    function updateBanner(text, cls) {
      const b = document.getElementById("statusBanner");
      b.innerText = text;
      b.className = "status-banner " + cls;
      b.onclick = null;
      log("Banner:", text);
    }

    function enterCooldown() {
      isInCooldown = true;
      const overlay = document.querySelector('.scan-overlay');
      overlay.classList.remove('scanning');
      overlay.classList.add('cooldown');
      
      log('Cooldown started');
      
      cooldownTimer = setTimeout(() => {
        exitCooldown();
      }, COOLDOWN_DURATION);
    }

    function exitCooldown() {
      isInCooldown = false;
      const overlay = document.querySelector('.scan-overlay');
      overlay.classList.remove('cooldown');
      overlay.classList.add('scanning');
      
      log('Cooldown ended');
    }

    async function initZXingScanner() {
      try {
        if (codeReader) {
          codeReader.reset();
        }

        codeReader = new ZXing.BrowserQRCodeReader();
        
        const videoInputDevices = await codeReader.listVideoInputDevices();
        log('Available cameras:', videoInputDevices.length);
        
        if (videoInputDevices.length === 0) {
          throw new Error('No camera found');
        }
        
        const selectedDeviceId = videoInputDevices.find(device => 
          device.label.toLowerCase().includes('back') || 
          device.label.toLowerCase().includes('environment')
        )?.deviceId || videoInputDevices[0]?.deviceId;
        
        const constraints = {
          video: {
            deviceId: { exact: selectedDeviceId },
            facingMode: { ideal: 'environment' },
            width: { ideal: 1280 },
            height: { ideal: 720 },
            aspectRatio: { ideal: 16/9 }
          }
        };
        
        await codeReader.decodeFromConstraints(
          constraints,
          'reader',
          (result, error) => {
            if (result) {
              onScanSuccess(result.text);
            }
          }
        );
        
        log('ZXing scanner started successfully');
        updateBanner("SYNCING STATUS...", "status-waiting");
        await syncSystemCache();
        
      } catch (err) {
        console.error('ZXing initialization failed:', err);
        updateBanner("CAMERA ERROR. TAP TO RETRY", "status-error");
        document.getElementById("startOverlay").style.display = "flex";
      }
    }

    async function stopZXingScanner() {
      if (codeReader) {
        codeReader.reset();
        log('ZXing scanner stopped');
      }
    }

    async function userStart() {
      await initEnhancedAudio();
      initHapticCapabilities(); // PHASE II: Test haptic support
      
      triggerHaptic('success');
      document.getElementById("startOverlay").style.display = "none";
      updateBanner("STARTING CAMERA...", "status-waiting");
      await initZXingScanner();
    }

    async function syncSystemCache(retryCount = 0) {
      const maxRetries = 3;
      try {
        updateBanner("üîÑ LOADING SYSTEM DATA...", "status-waiting");
        
        const resp = await fetch(SCRIPT_URL, { method: "GET", cache: "no-cache" });
        if (!resp.ok) throw new Error("HTTP " + resp.status);
        const data = await resp.json();
        if (!data.success) throw new Error(data.error || "Bad response");

        unavailableIpads = (data.borrowed || [])
          .map(x => (x || "").toString().trim().toUpperCase())
          .filter(Boolean);

        knownUsersSet = new Set(
          (data.userIds || [])
            .map(x => (x || "").toString().trim().toUpperCase())
            .filter(Boolean)
        );

        knownIpadsSet = new Set(
          (data.inventoryIds || [])
            .map(x => (x || "").toString().trim().toUpperCase())
            .filter(Boolean)
        );

        log("Cache synced:", {
          unavailable: unavailableIpads.length,
          users: knownUsersSet.size,
          inventory: knownIpadsSet.size
        });

        // CRITICAL: Validate that essential data is loaded
        if (knownUsersSet.size === 0) {
          throw new Error("User roster is empty - check User Roster sheet");
        }
        
        if (knownIpadsSet.size === 0) {
          throw new Error("iPad inventory is empty - check iPad Inventory sheet");
        }

        // Success - data loaded
        const statusMsg = userId 
          ? `‚úì READY - SCAN NEXT IPAD (${knownUsersSet.size} users, ${knownIpadsSet.size} iPads loaded)` 
          : `üë§ READY - SCAN YOUR USER ID (${knownUsersSet.size} users, ${knownIpadsSet.size} iPads loaded)`;
        
        updateBanner(statusMsg, "status-success");
        
        log("‚úÖ System ready - Users:", knownUsersSet.size, "iPads:", knownIpadsSet.size);

      } catch (err) {
        log("Sync failed:", err);
        if (retryCount < maxRetries) {
          updateBanner(`‚ö†Ô∏è LOADING DATA... (Attempt ${retryCount + 1}/${maxRetries})`, "status-warning");
          setTimeout(() => syncSystemCache(retryCount + 1), 1000 * (retryCount + 1));
        } else {
          updateBanner("‚ùå DATA LOAD FAILED - CHECK CONNECTION & RELOAD PAGE", "status-error");
          log("‚ùå Critical: Failed to load system data after", maxRetries, "attempts");
        }
      }
    }

    function makeRequestId() {
      try {
        if (crypto && crypto.randomUUID) return crypto.randomUUID();
      } catch (e) {}
      return "RID_" + Date.now() + "_" + Math.random().toString(16).slice(2);
    }

    function onScanSuccess(decodedText) {
      const now = Date.now();
      const clean = (decodedText || "").toString().trim().toUpperCase();
      if (!clean) return;

      if (isInCooldown) {
        log("Scan blocked - in cooldown");
        return;
      }

      if (clean === lastScanned && (now - lastScanTime) < DUPLICATE_WINDOW) {
        updateBanner("‚ö†Ô∏è ALREADY SCANNED - MOVE TO NEXT IPAD", "status-warning");
        triggerFeedback('warning');
        return;
      }

      lastScanned = clean;
      lastScanTime = now;

      // STEP 1: User ID Scan
      if (!userId) {
        // CRITICAL FIX #1: Pattern-based validation to detect iPad IDs
        // iPad IDs typically follow patterns like: IPAD-XXX, IPAD_XXX, IPADXXX, etc.
        const iPadPatterns = [
          /^IPAD[-_]?\d+$/i,      // IPAD-111, IPAD_111, IPAD111
          /^PAD[-_]?\d+$/i,       // PAD-111, PAD_111, PAD111
          /^TABLET[-_]?\d+$/i,    // TABLET-111, TABLET_111
          /^ASSET[-_]?\d+$/i,     // ASSET-111, ASSET_111
          /^\d{3,6}$/,            // Pure numbers like 111, 1234 (common for assets)
        ];
        
        const looksLikeIpadId = iPadPatterns.some(pattern => pattern.test(clean));
        
        if (looksLikeIpadId) {
          updateBanner("‚ùå THIS LOOKS LIKE AN IPAD ID - SCAN YOUR USER ID FIRST", "status-error");
          triggerFeedback('error');
          log("Rejected: Pattern matched iPad ID format:", clean);
          return;
        }
        
        // CRITICAL FIX #2: Check against known iPad inventory
        if (knownIpadsSet.size > 0 && knownIpadsSet.has(clean)) {
          updateBanner("‚ùå THIS IS AN IPAD ID - SCAN YOUR USER ID FIRST", "status-error");
          triggerFeedback('error');
          log("Rejected: iPad ID found in inventory:", clean);
          return;
        }
        
        // CRITICAL FIX #3: REQUIRE cache to be loaded before accepting User IDs
        if (knownUsersSet.size === 0 && knownIpadsSet.size === 0) {
          updateBanner("‚ö†Ô∏è LOADING DATA - PLEASE WAIT...", "status-warning");
          triggerFeedback('warning');
          log("Cache not loaded yet - rejecting scan");
          // Trigger sync if not already in progress
          syncSystemCache();
          return;
        }
        
        let isValidUser = false;
        
        if (knownUsersSet.size > 0) {
          if (knownUsersSet.has(clean)) {
            isValidUser = true;
          } else {
            updateBanner("‚ùå USER ID NOT RECOGNIZED - SCAN AGAIN", "status-error");
            triggerFeedback('error');
            log("User not in roster:", clean);
            return;
          }
        } else {
          // This should never happen due to Fix #3 above
          updateBanner("‚ö†Ô∏è DATA NOT LOADED - PLEASE WAIT", "status-warning");
          triggerFeedback('warning');
          log("Rejecting scan - cache still loading");
          return;
        }

        if (isValidUser) {
          userId = clean;
          
          showUserConfirmationModal(userId, "");
          
          document.getElementById("userPanel").style.display = "flex";
          document.getElementById("currentUserId").innerText = userId;
          updateBanner("‚úÖ USER VERIFIED - NOW SCAN IPADS", "status-success");
          
          triggerFeedback('success');
          enterCooldown();
        }
        return;
      }

      // STEP 2: iPad/Asset ID Scan
      // CRITICAL FIX #1: Pattern-based validation to detect User IDs
      // User IDs typically follow patterns different from iPad IDs
      const userIdPatterns = [
        /^STUDENT[-_]?\d+$/i,    // STUDENT-12345, STUDENT_12345
        /^STAFF[-_]?\d+$/i,      // STAFF-123, STAFF_123
        /^TEACHER[-_]?\d+$/i,    // TEACHER-123
        /^USER[-_]?\d+$/i,       // USER-123
        /^[A-Z]{2,}\d{4,}$/,     // TC12345, ST12345 (prefix + numbers)
      ];
      
      const looksLikeUserId = userIdPatterns.some(pattern => pattern.test(clean));
      
      if (looksLikeUserId) {
        updateBanner("‚ùå THIS LOOKS LIKE A USER ID - SCAN AN IPAD ASSET TAG", "status-error");
        triggerFeedback('error');
        log("Rejected: Pattern matched User ID format:", clean);
        return;
      }
      
      // CRITICAL FIX #2: Check against known User roster
      if (knownUsersSet.size > 0 && knownUsersSet.has(clean)) {
        updateBanner("‚ùå THIS IS A USER ID - SCAN AN IPAD ASSET TAG", "status-error");
        triggerFeedback('error');
        log("Rejected: User ID scanned instead of iPad ID:", clean);
        return;
      }
      
      let isValidAsset = false;
      
      if (knownIpadsSet.size > 0) {
        if (knownIpadsSet.has(clean)) {
          isValidAsset = true;
        } else {
          updateBanner("‚ùå IPAD NOT IN SYSTEM - CHECK ASSET TAG", "status-error");
          triggerFeedback('error');
          log("Asset not in inventory:", clean);
          return;
        }
      } else {
        // CRITICAL FIX #3: Don't accept anything if cache not loaded
        updateBanner("‚ö†Ô∏è DATA NOT LOADED - PLEASE WAIT", "status-warning");
        triggerFeedback('warning');
        log("Rejecting scan - inventory cache not loaded");
        return;
      }

      if (isValidAsset) {
        if (mode === "borrow" && unavailableIpads.includes(clean)) {
          updateBanner("‚ùå CANNOT BORROW - RESERVED OR IN USE", "status-error");
          triggerFeedback('error');
          return;
        }

        if (sessionHistory.includes(clean)) {
          updateBanner("‚ö†Ô∏è ALREADY SCANNED IN THIS SESSION", "status-warning");
          triggerFeedback('warning');
          return;
        }

        sessionHistory.push(clean);
        addHistoryRowBottom_(clean);

        updateBanner("‚úì " + clean + " - SCAN NEXT", "status-success");
        triggerFeedback('success');
        
        enterCooldown();
        return;
      }

      updateBanner("‚ùå INVALID QR CODE - SCAN AGAIN", "status-error");
      triggerFeedback('error');
    }

    function updateCount_() {
      document.getElementById("sessionCount").innerText = "Qty: " + sessionHistory.length;
    }

    function ensureHistoryVisible_() {
      const list = document.getElementById("historyList");
      if (list.style.display !== "block") list.style.display = "block";
    }

    function addHistoryRowBottom_(ipadId) {
      const list = document.getElementById("historyList");
      ensureHistoryVisible_();

      const row = document.createElement("div");
      row.className = "history-row status-pending";
      row.setAttribute("data-ipad-id", ipadId);

      const content = document.createElement("div");
      content.className = "history-content";

      const labelWrapper = document.createElement("div");
      labelWrapper.className = "history-label";

      const statusIcon = document.createElement("span");
      statusIcon.className = "status-icon pending";
      statusIcon.textContent = "‚óã";

      const label = document.createElement("span");
      label.textContent = ipadId;

      labelWrapper.appendChild(statusIcon);
      labelWrapper.appendChild(label);
      content.appendChild(labelWrapper);

      const btn = document.createElement("button");
      btn.className = "delete-btn";
      btn.textContent = "DELETE";
      btn.onclick = () => removeById_(ipadId);

      row.appendChild(content);
      row.appendChild(btn);

      list.appendChild(row);
      historyDom.set(ipadId, row);
      ipadStatus.set(ipadId, { status: 'pending' }); // PHASE III: Initialize status
      updateCount_();
    }

    // PHASE III: Update history row with success/failure status
    function updateHistoryRowStatus_(ipadId, success, errorMessage = null) {
      const row = historyDom.get(ipadId);
      if (!row) return;

      const content = row.querySelector('.history-content');
      const statusIcon = row.querySelector('.status-icon');
      const deleteBtn = row.querySelector('.delete-btn');
      
      // Update status tracking
      ipadStatus.set(ipadId, { 
        status: success ? 'success' : 'failed',
        error: errorMessage 
      });

      // Update visual state
      row.classList.remove('status-pending', 'status-success', 'status-failed');
      statusIcon.classList.remove('pending', 'success', 'failed');

      if (success) {
        row.classList.add('status-success');
        statusIcon.classList.add('success');
        statusIcon.textContent = "‚úì";
      } else {
        row.classList.add('status-failed');
        statusIcon.classList.add('failed');
        statusIcon.textContent = "‚úó";

        // Add error reason if provided
        if (errorMessage) {
          // Remove any existing error reason
          const existingError = content.querySelector('.error-reason');
          if (existingError) existingError.remove();

          // Convert backend message to user-friendly format
          const friendlyMessage = getShortErrorMessage_(errorMessage);

          const errorReason = document.createElement("div");
          errorReason.className = "error-reason";
          errorReason.textContent = friendlyMessage;
          content.appendChild(errorReason);
        }
      }

      // UX FIX: Hide delete button for ALL items after "Finish and Save"
      // Once the save operation completes, users should only VIEW results, not edit
      // This creates a clear "final confirmation" state
      if (deleteBtn) {
        deleteBtn.style.display = 'none';
      }

      log(`Updated ${ipadId} status:`, success ? 'SUCCESS' : 'FAILED', errorMessage || '');
    }

    // PHASE III: Convert backend error messages to short, user-friendly format
    function getShortErrorMessage_(message) {
      const msg = (message || "").toLowerCase();
      
      if (msg.includes("not borrowed") || msg.includes("not currently")) {
        return "Not checked out";
      }
      if (msg.includes("already borrowed") || msg.includes("already checked out")) {
        return "Already in use";
      }
      if (msg.includes("not found") || msg.includes("does not exist")) {
        return "Not in system";
      }
      if (msg.includes("borrowed by") && msg.includes("not ")) {
        return "Borrowed by someone else";
      }
      if (msg.includes("blocked") || msg.includes("maintenance") || msg.includes("reserved")) {
        return "Reserved/Maintenance";
      }
      
      // Default: truncate long messages
      if (message.length > 35) {
        return message.substring(0, 32) + "...";
      }
      
      return message;
    }

    function removeById_(ipadId) {
      const idx = sessionHistory.indexOf(ipadId);
      if (idx >= 0) sessionHistory.splice(idx, 1);

      const el = historyDom.get(ipadId);
      if (el && el.parentNode) el.parentNode.removeChild(el);
      historyDom.delete(ipadId);
      ipadStatus.delete(ipadId); // PHASE III: Clean up status tracking

      updateCount_();
      if (sessionHistory.length === 0) {
        document.getElementById("historyList").style.display = "none";
        updateBanner(userId ? "‚úì READY - SCAN NEXT IPAD" : "üë§ STEP 1: SCAN YOUR USER ID", "status-waiting");
      }
    }

    function clearHistoryDom_() {
      historyDom.clear();
      ipadStatus.clear(); // PHASE III: Clear status tracking
      const list = document.getElementById("historyList");
      list.innerHTML = "";
    }

    async function clearAll() {
      if (sessionHistory.length === 0 && !userId) return;

      if (confirm("Clear and reset for next user?")) {
        resetAll();
        await stopZXingScanner();
        await initZXingScanner();
      }
    }

    function resetAll() {
      userId = null;
      sessionHistory = [];
      ipadStatus.clear(); // PHASE III: Clear status tracking
      isProcessing = false;
      document.getElementById("finishBtn").disabled = false;
      document.getElementById("userPanel").style.display = "none";
      document.getElementById("historyList").style.display = "none";
      clearHistoryDom_();
      updateCount_();
      updateBanner("üë§ STEP 1: SCAN YOUR USER ID", "status-waiting");
      
      if (cooldownTimer) clearTimeout(cooldownTimer);
      exitCooldown();
    }

    function setMode(m) {
      if (isProcessing) {
        updateBanner("SAVING IN PROGRESS", "status-warning");
        return;
      }
      
      mode = m;
      document.getElementById("btnBorrow").classList.toggle("active", m === "borrow");
      document.getElementById("btnReturn").classList.toggle("active", m === "return");
      
      resetAll();
      syncSystemCache();
    }

    // PHASE II: Enhanced finishSession with detailed error handling
    async function finishSession() {
      if (!userId || sessionHistory.length === 0 || isProcessing) return;

      isProcessing = true;
      document.getElementById("finishBtn").disabled = true;
      updateBanner("SAVING...", "status-warning");

      const payload = {
        action: mode,
        userId: userId,
        ipadIds: sessionHistory,
        requestId: makeRequestId()
      };

      const maxRetries = 3;

      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          const controller = new AbortController();
          const t = setTimeout(() => controller.abort(), 15000);

          const resp = await fetch(SCRIPT_URL, {
            method: "POST",
            headers: { "Content-Type": "text/plain;charset=utf-8" },
            body: JSON.stringify(payload),
            signal: controller.signal
          });

          clearTimeout(t);

          let result = null;
          try { result = await resp.json(); } catch (e) {}

          // PHASE III: Handle partial success - update individual iPad statuses
          if (result && result.results && Array.isArray(result.results)) {
            log("Processing individual iPad results:", result.results);
            
            // Update each iPad's status in the UI
            for (const ipadResult of result.results) {
              const ipadId = (ipadResult.ipadId || "").toString().trim().toUpperCase();
              const success = ipadResult.success === true;
              const errorMsg = success ? null : (ipadResult.message || "Transaction failed");
              
              updateHistoryRowStatus_(ipadId, success, errorMsg);
            }

            // If ALL succeeded, proceed to completion
            if (result.success) {
              updateBanner("‚úÖ SAVED SUCCESSFULLY - READY FOR NEXT USER", "status-success");
              triggerFeedback('complete');

              await syncSystemCache();

              setTimeout(resetAll, 700);
              return;
            }

            // PARTIAL SUCCESS: Show error but keep failed items visible
            const successCount = result.results.filter(r => r.success).length;
            const totalCount = result.results.length;
            const failedCount = totalCount - successCount;

            if (successCount > 0) {
              // Some succeeded - show partial success message
              updateBanner(
                `‚ö†Ô∏è ${failedCount} FAILED - CHECK ITEMS MARKED WITH ‚úó`,
                "status-warning"
              );
              triggerFeedback('warning');
            } else {
              // All failed - show error
              updateBanner("‚ùå ALL ITEMS FAILED - CHECK ERRORS BELOW", "status-error");
              triggerFeedback('error');
            }

            isProcessing = false;
            document.getElementById("finishBtn").disabled = false;
            return;
          }

          // Original success handling (if no results array)
          if (result && result.success) {
            updateBanner("‚úÖ SAVED SUCCESSFULLY - READY FOR NEXT USER", "status-success");
            triggerFeedback('complete');

            await syncSystemCache();

            setTimeout(resetAll, 700);
            return;
          }

          // PHASE II: Enhanced error handling with specific codes
          if (result && result.errorCode) {
            const errorCode = result.errorCode;
            const errorMessage = result.message || result.error || "Transaction failed";
            const details = result.details || {};
            
            showErrorModal(errorCode, errorMessage, details);
            
            isProcessing = false;
            document.getElementById("finishBtn").disabled = false;
            return;
          }

          if (result && (result.error || result.message)) {
            const msg = (result.message || result.error || "SAVE FAILED").toString().toUpperCase();
            updateBanner(msg, "status-error");
            triggerFeedback('error');
            isProcessing = false;
            document.getElementById("finishBtn").disabled = false;
            return;
          }

          throw new Error("Save failed");

        } catch (err) {
          log("Save attempt failed:", attempt, err);

          if (err.name === 'AbortError') {
            showErrorModal('NETWORK_ERROR', 'Request timed out after 15 seconds', {});
            isProcessing = false;
            document.getElementById("finishBtn").disabled = false;
            return;
          }

          if (attempt < maxRetries) {
            updateBanner("RETRYING " + attempt + " OF " + maxRetries, "status-warning");
            await new Promise(r => setTimeout(r, 700 * attempt));
          } else {
            triggerFeedback('error');
            updateBanner("SAVE FAILED. TAP TO RETRY", "status-error");

            isProcessing = false;
            document.getElementById("finishBtn").disabled = false;

            document.getElementById("statusBanner").onclick = () => {
              document.getElementById("statusBanner").onclick = null;
              showConfirmationModal();
            };
          }
        }
      }
    }
  </script>
</body>
</html>
